// OfficeX filesharing app (clone of google drive)
// where possible, show the code changes as green diffs without the +/- symbols



# Webhooks

Webhooks on OfficeX Drive events let us integrate into systems as a primitive.
Here are some example potential events to receieve webhook alerts on, along with their alt_index and filters.

Quick Notes:

- `alt_index` is a resource_id that differs per event type. it might be a FileID or a FolderID, etc
- `filters` is a string that differs per event type. it might be filters on a path or a user, etc

```js
const webhook_events = [
  { label: "file.viewed", alt_index: `${FileID}`, filters: "by___" },
  { label: "file.created", alt_index: "FILE_CREATED", filters: "by___" },
  { label: "file.updated", alt_index: `${FileID}`, filters: "by___" },
  { label: "file.deleted", alt_index: `${FileID}`, filters: "by___" },
  { label: "file.shared", alt_index: `${FileID}`, filters: "by___" },
  { label: "folder.viewed", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.created", alt_index: "FOLDER_CREATED", filters: "by___" },
  { label: "folder.updated", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.deleted", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.shared", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.file.created", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.file.updated", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.file.deleted", alt_index: `${FolderID}`, filters: "by___" },
  { label: "folder.file.shared", alt_index: `${FolderID}`, filters: "by___" },
  { label: "team.invite.created", alt_index: `${TeamID}`, filters: "by___" },
  { label: "team.invite.updated", alt_index: `${TeamID}`, filters: "by___" },
  { label: "___.___", alt_index: "___ID", filters: "by___" },
  { label: "___.___", alt_index: "___ID", filters: "by___" },
];
```

Not sure if we should be super granular via alt_index or just use more robust filters. Also there are many other state resources with CRUD operations. should we include them? might be overkill?

- api_keys
- contacts
- disks
- drives
- webhooks


// src/core/state/webhooks/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::core::state::webhooks::types::{Webhook, WebhookAltIndexID, WebhookID};
    
    thread_local! {
        // users pass in api key value, we O(1) lookup the api key id + O(1) lookup the api key
        pub(crate) static WEBHOOKS_BY_ALT_INDEX_HASHTABLE: RefCell<HashMap<WebhookAltIndexID, Vec<WebhookID>>> = RefCell::new(HashMap::new());
        // default is to use the api key id to lookup the api key
        pub(crate) static WEBHOOKS_BY_ID_HASHTABLE: RefCell<HashMap<WebhookID, Webhook>> = RefCell::new(HashMap::new());
        // track in hashtable users list of ApiKeyIDs
        pub(crate) static WEBHOOKS_BY_TIME_LIST: RefCell<Vec<WebhookID>> = RefCell::new(Vec::new());
    }

}



// src/core/state/webhooks/types.rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WebhookID(pub String);

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct WebhookAltIndexID(pub String);

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Webhook {
    pub id: WebhookID,
    pub url: String,
    pub alt_index: WebhookAltIndexID,
    pub event: WebhookEventLabel,
    pub signature: String,
    pub description: String,
    pub active: bool,
}



#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum WebhookEventLabel {
    #[serde(rename = "file.viewed")]
    FileViewed,
    #[serde(rename = "file.created")]
    FileCreated,
    #[serde(rename = "file.updated")]
    FileUpdated,
    #[serde(rename = "file.deleted")]
    FileDeleted,
    #[serde(rename = "file.shared")]
    FileShared,
    #[serde(rename = "folder.viewed")]
    FolderViewed,
    #[serde(rename = "folder.created")]
    FolderCreated,
    #[serde(rename = "folder.updated")]
    FolderUpdated,
    #[serde(rename = "folder.deleted")]
    FolderDeleted,
    #[serde(rename = "folder.shared")]
    FolderShared,
    #[serde(rename = "folder.file.created")]
    FolderFileCreated,
    #[serde(rename = "folder.file.updated")]
    FolderFileUpdated,
    #[serde(rename = "folder.file.deleted")]
    FolderFileDeleted,
    #[serde(rename = "folder.file.shared")]
    FolderFileShared,
    #[serde(rename = "team.invite.created")]
    TeamInviteCreated,
    #[serde(rename = "team.invite.updated")]
    TeamInviteUpdated,
    #[serde(rename = "drive.gas_low")]
    DriveGasLow,
    #[serde(rename = "drive.sync_completed")]
    DriveSyncCompleted,
}

impl std::str::FromStr for WebhookEventLabel {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "file.viewed" => Ok(Self::FileViewed),
            "file.created" => Ok(Self::FileCreated),
            "file.updated" => Ok(Self::FileUpdated),
            "file.deleted" => Ok(Self::FileDeleted),
            "file.shared" => Ok(Self::FileShared),
            "folder.viewed" => Ok(Self::FolderViewed),
            "folder.created" => Ok(Self::FolderCreated),
            "folder.updated" => Ok(Self::FolderUpdated),
            "folder.deleted" => Ok(Self::FolderDeleted),
            "folder.shared" => Ok(Self::FolderShared),
            "folder.file.created" => Ok(Self::FolderFileCreated),
            "folder.file.updated" => Ok(Self::FolderFileUpdated),
            "folder.file.deleted" => Ok(Self::FolderFileDeleted),
            "folder.file.shared" => Ok(Self::FolderFileShared),
            "team.invite.created" => Ok(Self::TeamInviteCreated),
            "team.invite.updated" => Ok(Self::TeamInviteUpdated),
            "drive.gas_low" => Ok(Self::DriveGasLow),
            "drive.sync_completed" => Ok(Self::DriveSyncCompleted),
            _ => Err(format!("Invalid webhook event: {}", s)),
        }
    }
}

// Optionally, if you need to convert back to string representation
impl ToString for WebhookEventLabel {
    fn to_string(&self) -> String {
        match self {
            Self::FileViewed => "file.viewed",
            Self::FileCreated => "file.created",
            Self::FileUpdated => "file.updated",
            Self::FileDeleted => "file.deleted",
            Self::FileShared => "file.shared",
            Self::FolderViewed => "folder.viewed",
            Self::FolderCreated => "folder.created",
            Self::FolderUpdated => "folder.updated",
            Self::FolderDeleted => "folder.deleted",
            Self::FolderShared => "folder.shared",
            Self::FolderFileCreated => "folder.file.created",
            Self::FolderFileUpdated => "folder.file.updated",
            Self::FolderFileDeleted => "folder.file.deleted",
            Self::FolderFileShared => "folder.file.shared",
            Self::TeamInviteCreated => "team.invite.created",
            Self::TeamInviteUpdated => "team.invite.updated",
            Self::DriveGasLow => "drive.gas_low",
            Self::DriveSyncCompleted => "drive.sync_completed",
        }.to_string()
    }
}


// src/rest/webhooks/types.rs

use serde::{Deserialize, Serialize};
use crate::core::state::webhooks::types::WebhookEventLabel;
use crate::core::state::webhooks::types::{WebhookID, Webhook};

#[derive(Debug, Clone, Serialize)]
pub enum WebhookResponse<'a, T = ()> {
    #[serde(rename = "ok")]
    Ok { data: &'a T },
    #[serde(rename = "err")]
    Err { code: u16, message: String },
}

impl<'a, T: Serialize> WebhookResponse<'a, T> {
    pub fn ok(data: &'a T) -> WebhookResponse<'a, T> { 
        Self::Ok { data }
    }

    pub fn not_found() -> Self {
        Self::err(404, "Not found".to_string())
    }

    pub fn unauthorized() -> Self {
        Self::err(401, "Unauthorized".to_string())
    }

    pub fn err(code: u16, message: String) -> Self {
        Self::Err { code, message }
    }

    pub fn encode(&self) -> Vec<u8> {
        serde_json::to_vec(self).expect("Failed to serialize value")
    }
}


#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SortDirection {
    Asc,
    Desc,
}

impl Default for SortDirection {
    fn default() -> Self {
        SortDirection::Asc
    }
}



#[derive(Debug, Clone, Deserialize)]
pub struct ListWebhooksRequestBody {
    #[serde(default)]
    pub filters: String,
    #[serde(default = "default_page_size")]
    pub page_size: usize,
    #[serde(default)]
    pub direction: SortDirection,
    pub cursor_up: Option<String>,
    pub cursor_down: Option<String>,
}

fn default_page_size() -> usize {
    50
}

#[derive(Debug, Clone, Serialize)]
pub struct ListWebhooksResponseData {
    pub items: Vec<Webhook>,
    pub page_size: usize,
    pub total: usize,
    pub cursor_up: Option<String>,
    pub cursor_down: Option<String>,
}


#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct CreateWebhookRequestBody {
    pub alt_index: String,
    pub url: String,
    pub event: String,
    pub signature: Option<String>,
    pub description: Option<String>,
}


#[derive(Debug, Clone, Deserialize)]
pub struct UpdateWebhookRequestBody {
    pub id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active: Option<bool>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
pub enum UpsertWebhookRequestBody {
    Create(CreateWebhookRequestBody),
    Update(UpdateWebhookRequestBody),
}


#[derive(Debug, Clone, Deserialize)]
pub struct DeleteWebhookRequest {
    pub id: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct DeletedWebhookData {
    pub id: WebhookID,
    pub deleted: bool
}


pub type GetWebhookResponse<'a> = WebhookResponse<'a, Webhook>;
pub type ListWebhooksResponse<'a> = WebhookResponse<'a, ListWebhooksResponseData>;
pub type CreateWebhookResponse<'a> = WebhookResponse<'a, Webhook>;
pub type UpdateWebhookResponse<'a> = WebhookResponse<'a, Webhook>;
pub type DeleteWebhookResponse<'a> = WebhookResponse<'a, DeletedWebhookData>;
pub type ErrorResponse<'a> = WebhookResponse<'a, ()>;

// src/rest/webhooks/route.rs
use crate::debug_log;
use crate::rest::router;
use crate::types::RouteHandler;

pub const WEBHOOKS_GET_PATH: &str = "/webhooks/get/{webhook_id}";
pub const WEBHOOKS_LIST_PATH: &str = "/webhooks/list";
pub const WEBHOOKS_UPSERT_PATH: &str = "/webhooks/upsert";
pub const WEBHOOKS_DELETE_PATH: &str = "/webhooks/delete";

type HandlerEntry = (&'static str, &'static str, RouteHandler);

pub fn init_routes() {
    let routes: &[HandlerEntry] = &[
        (
            "GET",
            WEBHOOKS_GET_PATH,
            crate::rest::webhooks::handler::webhooks_handlers::get_webhook_handler,
        ),
        (
            "POST",
            WEBHOOKS_LIST_PATH,
            crate::rest::webhooks::handler::webhooks_handlers::list_webhooks_handler,
        ),
        (
            "POST",
            WEBHOOKS_UPSERT_PATH,
            crate::rest::webhooks::handler::webhooks_handlers::upsert_webhook_handler,
        ),
        (
            "POST",
            WEBHOOKS_DELETE_PATH,
            crate::rest::webhooks::handler::webhooks_handlers::delete_webhook_handler,
        )
    ];

    for &(method, path, handler) in routes {
        debug_log!("Registering {} route: {}", method, path);
        router::insert_route(method, path, handler);
    }

}


// src/rest/webhooks/handler.rs


pub mod webhooks_handlers {
    use std::str::FromStr;

    use crate::{
        core::{
            api::uuid::generate_unique_id,
            state::{drives::state::state::OWNER_ID, webhooks::{
                state::state::{WEBHOOKS_BY_ALT_INDEX_HASHTABLE, WEBHOOKS_BY_ID_HASHTABLE, WEBHOOKS_BY_TIME_LIST}, types::{Webhook, WebhookAltIndexID, WebhookEventLabel, WebhookID}
            }}
        },
        debug_log,
        rest::{
            auth::{authenticate_request, create_auth_error_response}, webhooks::types::{
                CreateWebhookRequestBody, CreateWebhookResponse, DeleteWebhookRequest, DeleteWebhookResponse, DeletedWebhookData, ErrorResponse, GetWebhookResponse, ListWebhooksRequestBody, ListWebhooksResponse, ListWebhooksResponseData, SortDirection, UpdateWebhookRequestBody, UpdateWebhookResponse, UpsertWebhookRequestBody
            }
        },
    };
    use ic_http_certification::{HttpRequest, HttpResponse, StatusCode};
    use matchit::Params;
    use serde::Deserialize;

    // pub fn get_webhook_handler(_req: &HttpRequest, params: &Params) -> HttpResponse<'static> {
    //     // authenticate_request from auth.rs
    //     // only owner can set webhooks
    //     // fetch webhook from state WEBHOOKS_BY_ID_HASHTABLE
    //     // return 404 if not found
    //     // return 200 if found with webhook data
    // }
    pub fn get_webhook_handler(req: &HttpRequest, params: &Params) -> HttpResponse<'static> {
        // Authenticate request
        let requester_api_key = match authenticate_request(req) {
            Some(key) => key,
            None => return create_auth_error_response(),
        };

        // Only owner can access webhooks
        let is_owner = OWNER_ID.with(|owner_id| requester_api_key.user_id == *owner_id);
        if !is_owner {
            return create_auth_error_response();
        }

        // Get webhook ID from params
        let webhook_id = WebhookID(params.get("webhook_id").unwrap().to_string());

        // Get the webhook
        let webhook = WEBHOOKS_BY_ID_HASHTABLE.with(|store| {
            store.borrow().get(&webhook_id).cloned()
        });

        match webhook {
            Some(hook) => create_response(
                StatusCode::OK,
                GetWebhookResponse::ok(&hook).encode()
            ),
            None => create_response(
                StatusCode::NOT_FOUND, 
                ErrorResponse::not_found().encode()
            ),
        }
    }

    // pub fn list_webhooks_handler(request: &HttpRequest, _params: &Params) -> HttpResponse<'static> {
    //     // authenticate_request from auth.rs
    //     // only owner can set webhooks
    //     // fetch batch of 25 webhooks from state WEBHOOKS_BY_TIME_LIST + WEBHOOKS_BY_ID_HASHTABLE
    //     // set cursors for pagination (cursor_up u32 and cursor_down u32) representing index in vector
    //     // return 200 with list of webhooks
    // }

    pub fn list_webhooks_handler(request: &HttpRequest, _params: &Params) -> HttpResponse<'static> {
        // Authenticate request
        let requester_api_key = match authenticate_request(request) {
            Some(key) => key,
            None => return create_auth_error_response(),
        };
    
        // Only owner can access webhooks
        let is_owner = OWNER_ID.with(|owner_id| requester_api_key.user_id == *owner_id);
        if !is_owner {
            return create_auth_error_response();
        }
    
        // Parse request body
        let body = request.body();
        let request_body: ListWebhooksRequestBody = match serde_json::from_slice(body) {
            Ok(body) => body,
            Err(_) => return create_response(
                StatusCode::BAD_REQUEST,
                ErrorResponse::err(400, "Invalid request format".to_string()).encode()
            ),
        };
    
        // Parse cursors if provided
        let cursor_up = if let Some(cursor) = request_body.cursor_up {
            match cursor.parse::<usize>() {
                Ok(idx) => Some(idx),
                Err(_) => return create_response(
                    StatusCode::BAD_REQUEST,
                    ErrorResponse::err(400, "Invalid cursor_up format".to_string()).encode()
                ),
            }
        } else {
            None
        };
    
        let cursor_down = if let Some(cursor) = request_body.cursor_down {
            match cursor.parse::<usize>() {
                Ok(idx) => Some(idx),
                Err(_) => return create_response(
                    StatusCode::BAD_REQUEST,
                    ErrorResponse::err(400, "Invalid cursor_down format".to_string()).encode()
                ),
            }
        } else {
            None
        };
    
        // Get total count
        let total_count = WEBHOOKS_BY_TIME_LIST.with(|list| list.borrow().len());
    
        // If there are no webhooks, return early
        if total_count == 0 {
            return create_response(
                StatusCode::OK,
                ListWebhooksResponse::ok(&ListWebhooksResponseData {
                    items: vec![],
                    page_size: 0,
                    total: 0,
                    cursor_up: None,
                    cursor_down: None,
                }).encode()
            );
        }
    
        // Determine starting point based on cursors
        let start_index = if let Some(up) = cursor_up {
            up.min(total_count - 1)
        } else if let Some(down) = cursor_down {
            down.min(total_count - 1)
        } else {
            match request_body.direction {
                SortDirection::Asc => 0,
                SortDirection::Desc => total_count - 1,
            }
        };
    
        // Get webhooks with pagination and filtering
        let mut filtered_webhooks = Vec::new();
        let mut processed_count = 0;
    
        WEBHOOKS_BY_TIME_LIST.with(|time_index| {
            let time_index = time_index.borrow();
            WEBHOOKS_BY_ID_HASHTABLE.with(|id_store| {
                let id_store = id_store.borrow();
                
                match request_body.direction {
                    SortDirection::Desc => {
                        // Newest first
                        let mut current_idx = start_index;
                        while filtered_webhooks.len() < request_body.page_size && current_idx < total_count {
                            if let Some(webhook) = id_store.get(&time_index[current_idx]) {
                                if request_body.filters.is_empty() || webhook.event.to_string().contains(&request_body.filters) {
                                    filtered_webhooks.push(webhook.clone());
                                }
                            }
                            if current_idx == 0 {
                                break;
                            }
                            current_idx -= 1;
                            processed_count = start_index - current_idx;
                        }
                    },
                    SortDirection::Asc => {
                        // Oldest first
                        let mut current_idx = start_index;
                        while filtered_webhooks.len() < request_body.page_size && current_idx < total_count {
                            if let Some(webhook) = id_store.get(&time_index[current_idx]) {
                                if request_body.filters.is_empty() || webhook.event.to_string().contains(&request_body.filters) {
                                    filtered_webhooks.push(webhook.clone());
                                }
                            }
                            current_idx += 1;
                            processed_count = current_idx - start_index;
                        }
                    }
                }
            });
        });
    
        // Calculate next cursors based on direction and current position
        let (cursor_up, cursor_down) = match request_body.direction {
            SortDirection::Desc => {
                let next_up = if start_index < total_count - 1 {
                    Some((start_index + 1).to_string())
                } else {
                    None
                };
                let next_down = if processed_count > 0 && start_index >= processed_count {
                    Some((start_index - processed_count).to_string())
                } else {
                    None
                };
                (next_up, next_down)
            },
            SortDirection::Asc => {
                let next_up = if processed_count > 0 {
                    Some((start_index + processed_count).to_string())
                } else {
                    None
                };
                let next_down = if start_index > 0 {
                    Some((start_index - 1).to_string())
                } else {
                    None
                };
                (next_up, next_down)
            }
        };
    
        // Create response
        let response_data = ListWebhooksResponseData {
            items: filtered_webhooks.clone(),
            page_size: filtered_webhooks.len(),
            total: total_count,
            cursor_up,
            cursor_down,
        };
    
        create_response(
            StatusCode::OK,
            ListWebhooksResponse::ok(&response_data).encode()
        )
    }


    // pub fn upsert_webhook_handler(req: &HttpRequest, _params: &Params) -> HttpResponse<'static> {
    //     // authenticate_request from auth.rs
    //     // only owner can set webhooks
    //     // check __type if create or edit
    //     // if create, generate unique id, create webhook, insert into state WEBHOOKS_BY_ID_HASHTABLE, WEBHOOKS_BY_ALT_INDEX_HASHTABLE, WEBHOOKS_BY_TIME_LIST
    //     // if edit, upsert changed fields into webhook, update state WEBHOOKS_BY_ID_HASHTABLE, WEBHOOKS_BY_ALT_INDEX_HASHTABLE (if alt_index changed, delete old entry and insert new entry)
    //     // return 200 with up to date webhook data
    // }

    pub fn upsert_webhook_handler(req: &HttpRequest, _params: &Params) -> HttpResponse<'static> {
        // Authenticate request
        let requester_api_key = match authenticate_request(req) {
            Some(key) => key,
            None => return create_auth_error_response(),
        };

        // Only owner can manage webhooks
        let is_owner = OWNER_ID.with(|owner_id| requester_api_key.user_id == *owner_id);
        if !is_owner {
            return create_auth_error_response();
        }

        // Parse request body
        let body: &[u8] = req.body();

        if let Ok(req) = serde_json::from_slice::<UpsertWebhookRequestBody>(body) {
            match req {
                UpsertWebhookRequestBody::Create(create_req) => {

                    // Create new webhook
                    let webhook_id = WebhookID(generate_unique_id("WebhookID", ""));
                    let alt_index = WebhookAltIndexID(create_req.alt_index);
                    let webhook = Webhook {
                        id: webhook_id.clone(),
                        alt_index: alt_index.clone(),
                        url: create_req.url,
                        event: WebhookEventLabel::from_str(&create_req.event).unwrap(),
                        signature: create_req.signature.unwrap_or_default(),
                        description: create_req.description.unwrap_or_default(),
                        active: true,
                    };

                    // Update state tables – now storing a Vec<WebhookID> without removing others
                    WEBHOOKS_BY_ALT_INDEX_HASHTABLE.with(|store| {
                        let mut store = store.borrow_mut();
                        store.entry(alt_index.clone())
                            .and_modify(|vec_ids| {
                                if !vec_ids.contains(&webhook_id) {
                                    vec_ids.push(webhook_id.clone());
                                }
                            })
                            .or_insert_with(|| vec![webhook_id.clone()]);
                    });

                    WEBHOOKS_BY_ID_HASHTABLE.with(|store| {
                        store.borrow_mut().insert(webhook_id.clone(), webhook.clone());
                    });

                    WEBHOOKS_BY_TIME_LIST.with(|store| {
                        store.borrow_mut().push(webhook_id.clone());
                    });

                    create_response(
                        StatusCode::OK,
                        CreateWebhookResponse::ok(&webhook).encode()
                    )
                },
                UpsertWebhookRequestBody::Update(update_req) => {

                    let webhook_id = WebhookID(update_req.id);
                    
                    // Get existing webhook
                    let mut webhook = match WEBHOOKS_BY_ID_HASHTABLE.with(|store| store.borrow().get(&webhook_id).cloned()) {
                        Some(hook) => hook,
                        None => return create_response(
                            StatusCode::NOT_FOUND,
                            ErrorResponse::not_found().encode()
                        ),
                    };

                    // Update fields - ignoring alt_index and event as they cannot be modified
                    if let Some(url) = update_req.url {
                        webhook.url = url;
                    }
                    if let Some(signature) = update_req.signature {
                        webhook.signature = signature;
                    }
                    if let Some(description) = update_req.description {
                        webhook.description = description;
                    }
                    if let Some(active) = update_req.active {
                        webhook.active = active;
                    }

                    // Update webhook in ID table
                    WEBHOOKS_BY_ID_HASHTABLE.with(|store| {
                        store.borrow_mut().insert(webhook_id.clone(), webhook.clone());
                    });

                    create_response(
                        StatusCode::OK,
                        UpdateWebhookResponse::ok(&webhook).encode()
                    )
                }
            }
        } else {
            create_response(
                StatusCode::BAD_REQUEST,
                ErrorResponse::err(400, "Invalid request format".to_string()).encode()
            )
        }

    }

    pub fn delete_webhook_handler(req: &HttpRequest, _params: &Params) -> HttpResponse<'static> {
        // Authenticate request
        let requester_api_key = match authenticate_request(req) {
            Some(key) => key,
            None => return create_auth_error_response(),
        };

        // Only owner can manage webhooks
        let is_owner = OWNER_ID.with(|owner_id| requester_api_key.user_id == *owner_id);
        if !is_owner {
            return create_auth_error_response();
        }

        // Parse request body
        let body: &[u8] = req.body();
        let delete_request = match serde_json::from_slice::<DeleteWebhookRequest>(body) {
            Ok(req) => req,
            Err(_) => return create_response(
                StatusCode::BAD_REQUEST,
                ErrorResponse::err(400, "Invalid request format".to_string()).encode()
            ),
        };

        let webhook_id = WebhookID(delete_request.id.clone());

        // Get webhook to delete
        let webhook = match WEBHOOKS_BY_ID_HASHTABLE.with(|store| store.borrow().get(&webhook_id).cloned()) {
            Some(hook) => hook,
            None => return create_response(
                StatusCode::NOT_FOUND,
                ErrorResponse::not_found().encode()
            ),
        };

        // Remove from all hashtables
        WEBHOOKS_BY_ALT_INDEX_HASHTABLE.with(|store| {
            let mut map = store.borrow_mut();
            if let Some(ids) = map.get_mut(&webhook.alt_index) {
                ids.retain(|id| id != &webhook_id);
                if ids.is_empty() {
                    map.remove(&webhook.alt_index);
                }
            }
        });

        WEBHOOKS_BY_ID_HASHTABLE.with(|store| {
            store.borrow_mut().remove(&webhook_id);
        });

        WEBHOOKS_BY_TIME_LIST.with(|store| {
            store.borrow_mut().retain(|id| id != &webhook_id);
        });

        create_response(
            StatusCode::OK,
            DeleteWebhookResponse::ok(&DeletedWebhookData {
                id: webhook_id,
                deleted: true
            }).encode()
        )
    }

    fn json_decode<T>(value: &[u8]) -> T
    where
        T: for<'de> Deserialize<'de>,
    {
        serde_json::from_slice(value).expect("Failed to deserialize value")
    }

    fn create_response(status_code: StatusCode, body: Vec<u8>) -> HttpResponse<'static> {
        HttpResponse::builder()
            .with_status_code(status_code)
            .with_headers(vec![
                ("content-type".to_string(), "application/json".to_string()),
                (
                    "strict-transport-security".to_string(),
                    "max-age=31536000; includeSubDomains".to_string(),
                ),
                ("x-content-type-options".to_string(), "nosniff".to_string()),
                ("referrer-policy".to_string(), "no-referrer".to_string()),
                (
                    "cache-control".to_string(),
                    "no-store, max-age=0".to_string(),
                ),
                ("pragma".to_string(), "no-cache".to_string()),
            ])
            .with_body(body)
            .build()
    }
}



// src/core/state/api_keys/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;
    use crate::{core::{state::{api_keys::types::{ApiKey, ApiKeyID, ApiKeyValue}, drives::state::state::OWNER_ID}, types::UserID}, debug_log};

    thread_local! {
        // users pass in api key value, we O(1) lookup the api key id + O(1) lookup the api key
        pub(crate) static APIKEYS_BY_VALUE_HASHTABLE: RefCell<HashMap<ApiKeyValue, ApiKeyID>> = RefCell::new(HashMap::new());
        // default is to use the api key id to lookup the api key
        pub(crate) static APIKEYS_BY_ID_HASHTABLE: RefCell<HashMap<ApiKeyID, ApiKey>> = RefCell::new(HashMap::new());
        // track in hashtable users list of ApiKeyIDs
        pub(crate) static USERS_APIKEYS_HASHTABLE: RefCell<HashMap<UserID, Vec<ApiKeyID>>> = RefCell::new(HashMap::new());
    }

    // Helper functions to get debug string representations
    pub fn debug_apikeys_by_value() -> String {
        APIKEYS_BY_VALUE_HASHTABLE.with(|map| {
            format!("{:#?}", map.borrow())
        })
    }

    pub fn debug_apikeys_by_id() -> String {
        APIKEYS_BY_ID_HASHTABLE.with(|map| {
            format!("{:#?}", map.borrow())
        })
    }

    pub fn debug_users_apikeys() -> String {
        USERS_APIKEYS_HASHTABLE.with(|map| {
            format!("{:#?}", map.borrow())
        })
    }

    // Function to log all state
    pub fn debug_state() -> String {
        format!(
            "State Debug:\n\nAPIKEYS_BY_VALUE:\n{}\n\nAPIKEYS_BY_ID:\n{}\n\nUSERS_APIKEYS:\n{}",
            debug_apikeys_by_value(),
            debug_apikeys_by_id(),
            debug_users_apikeys()
        )
    }

    pub fn init_default_admin_apikey() {

        debug_log!("Initializing default admin api key...");

        let default_key = ApiKey {
            id: ApiKeyID("mock_api_key_id".to_string()),
            value: ApiKeyValue("mock_api_key_value".to_string()),
            user_id: OWNER_ID.with(|owner_id| owner_id.clone()),
            name: "Default Admin Key".to_string(),
            created_at: ic_cdk::api::time(),
            expires_at: -1,
            is_revoked: false,
        };

        debug_log!("Default admin api key: {}", default_key);

        APIKEYS_BY_VALUE_HASHTABLE.with(|map| {
            map.borrow_mut().insert(default_key.value.clone(), default_key.id.clone());
        });

        APIKEYS_BY_ID_HASHTABLE.with(|map| {
            map.borrow_mut().insert(default_key.id.clone(), default_key.clone());
        });

        USERS_APIKEYS_HASHTABLE.with(|map| {
            map.borrow_mut().insert(default_key.user_id.clone(), vec![default_key.id.clone()]);
        });
    }
}




// src/core/state/api_keys/types.rs

use serde::{Deserialize, Serialize};
use crate::core::types::UserID;
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ApiKeyID(pub String);

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ApiKeyValue(pub String);


// Implement Display for ApiKey
impl fmt::Display for ApiKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "ApiKey {{ id: {}, name: {}, user_id: {} }}", 
            self.id, self.name, self.user_id)
    }
}

#[derive(Debug, Clone, Serialize)]
pub struct ApiKey {
    pub id: ApiKeyID,
    pub value: ApiKeyValue,
    pub user_id: UserID,
    pub name: String,
    pub created_at: u64, 
    pub expires_at: i64, 
    pub is_revoked: bool,
}


// Implement Display for ApiKeyID
impl fmt::Display for ApiKeyID {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// Implement Display for ApiKeyValue
impl fmt::Display for ApiKeyValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}



// src/core/state/contacts/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::core::{state::contacts::types::Contact, types::UserID};
    
    thread_local! {
        // default is to use the api key id to lookup the api key
        pub(crate) static CONTACTS_BY_ID_HASHTABLE: RefCell<HashMap<UserID, Contact>> = RefCell::new(HashMap::new());
        // default is to use the api key id to lookup the api key
        pub(crate) static CONTACTS_BY_ICP_PRINCIPAL_HASHTABLE: RefCell<HashMap<String, UserID>> = RefCell::new(HashMap::new());
        // track in hashtable users list of ApiKeyIDs
        pub(crate) static CONTACTS_BY_TIME_LIST: RefCell<Vec<UserID>> = RefCell::new(Vec::new());
    }

}



// src/core/state/contacts/types.rs
use serde::{Serialize, Deserialize};

use crate::core::{state::teams::types::TeamID, types::{ICPPrincipalString, PublicKeyBLS, UserID}};



#[derive(Debug, Clone, Serialize)]
pub struct Contact {
    pub id: UserID,
    pub nickname: String,
    pub public_note: String,
    pub private_note: Option<String>,
    pub evm_public_address: String,
    pub icp_principal: ICPPrincipalString,
    pub teams: Vec<TeamID>
}   



// src/core/state/directory/state.rs

pub mod state {
    use std::cell::{RefCell, RefMut};
    use std::collections::HashMap;
    use std::ops::Deref;

    use crate::core::state::{
        directory::types::{DriveFullFilePath, FileMetadata, FileUUID, FolderMetadata, FolderUUID},
        templates::types::{TemplateID, TemplateItem},
    };

    // Wrapper types that implement Deref
    pub struct FolderMap;
    pub struct FileMap;
    pub struct FolderPathMap;
    pub struct FilePathMap;

    impl FolderMap {
        pub fn get(&self, key: &FolderUUID) -> Option<FolderMetadata> {
            folder_uuid_to_metadata_inner.with(|map| map.borrow().get(key).cloned())
        }

        pub fn insert(&self, key: FolderUUID, value: FolderMetadata) {
            folder_uuid_to_metadata_inner.with(|map| map.borrow_mut().insert(key, value));
        }

        pub fn with_mut<R>(&self, f: impl FnOnce(&mut HashMap<FolderUUID, FolderMetadata>) -> R) -> R {
            folder_uuid_to_metadata_inner.with(|map| f(&mut map.borrow_mut()))
        }
    
        pub fn contains_key(&self, key: &FolderUUID) -> bool {
            folder_uuid_to_metadata_inner.with(|map| map.borrow().contains_key(key))
        }
    
        pub fn remove(&self, key: &FolderUUID) -> Option<FolderMetadata> {
            folder_uuid_to_metadata_inner.with(|map| map.borrow_mut().remove(key))
        }
    }

    impl FileMap {
        pub fn get(&self, key: &FileUUID) -> Option<FileMetadata> {
            file_uuid_to_metadata_inner.with(|map| map.borrow().get(key).cloned())
        }

        pub fn insert(&self, key: FileUUID, value: FileMetadata) {
            file_uuid_to_metadata_inner.with(|map| map.borrow_mut().insert(key, value));
        }

        pub fn with_mut<R>(&self, f: impl FnOnce(&mut HashMap<FileUUID, FileMetadata>) -> R) -> R {
            file_uuid_to_metadata_inner.with(|map| f(&mut map.borrow_mut()))
        }
    
        pub fn contains_key(&self, key: &FileUUID) -> bool {
            file_uuid_to_metadata_inner.with(|map| map.borrow().contains_key(key))
        }
    
        pub fn remove(&self, key: &FileUUID) -> Option<FileMetadata> {
            file_uuid_to_metadata_inner.with(|map| map.borrow_mut().remove(key))
        }
    }

    impl FolderPathMap {
        pub fn get(&self, key: &DriveFullFilePath) -> Option<FolderUUID> {
            full_folder_path_to_uuid_inner.with(|map| map.borrow().get(key).cloned())
        }

        pub fn insert(&self, key: DriveFullFilePath, value: FolderUUID) {
            full_folder_path_to_uuid_inner.with(|map| map.borrow_mut().insert(key, value));
        }

        pub fn with_mut<R>(&self, f: impl FnOnce(&mut HashMap<DriveFullFilePath, FolderUUID>) -> R) -> R {
            full_folder_path_to_uuid_inner.with(|map| f(&mut map.borrow_mut()))
        }

        pub fn contains_key(&self, key: &DriveFullFilePath) -> bool {
            full_folder_path_to_uuid_inner.with(|map| map.borrow().contains_key(key))
        }
    
        pub fn remove(&self, key: &DriveFullFilePath) -> Option<FolderUUID> {
            full_folder_path_to_uuid_inner.with(|map| map.borrow_mut().remove(key))
        }
    }

    impl FilePathMap {
        pub fn get(&self, key: &DriveFullFilePath) -> Option<FileUUID> {
            full_file_path_to_uuid_inner.with(|map| map.borrow().get(key).cloned())
        }

        pub fn insert(&self, key: DriveFullFilePath, value: FileUUID) {
            full_file_path_to_uuid_inner.with(|map| map.borrow_mut().insert(key, value));
        }

        pub fn with_mut<R>(&self, f: impl FnOnce(&mut HashMap<DriveFullFilePath, FileUUID>) -> R) -> R {
            full_file_path_to_uuid_inner.with(|map| f(&mut map.borrow_mut()))
        }
    
        pub fn contains_key(&self, key: &DriveFullFilePath) -> bool {
            full_file_path_to_uuid_inner.with(|map| map.borrow().contains_key(key))
        }
    
        pub fn remove(&self, key: &DriveFullFilePath) -> Option<FileUUID> {
            full_file_path_to_uuid_inner.with(|map| map.borrow_mut().remove(key))
        }
    }

    // Private thread_local storage
    thread_local! {
        static folder_uuid_to_metadata_inner: RefCell<HashMap<FolderUUID, FolderMetadata>> = RefCell::new(HashMap::new());
        static file_uuid_to_metadata_inner: RefCell<HashMap<FileUUID, FileMetadata>> = RefCell::new(HashMap::new());
        static full_folder_path_to_uuid_inner: RefCell<HashMap<DriveFullFilePath, FolderUUID>> = RefCell::new(HashMap::new());
        static full_file_path_to_uuid_inner: RefCell<HashMap<DriveFullFilePath, FileUUID>> = RefCell::new(HashMap::new());
    }

    // Public instances with original names
    pub static folder_uuid_to_metadata: FolderMap = FolderMap;
    pub static file_uuid_to_metadata: FileMap = FileMap;
    pub static full_folder_path_to_uuid: FolderPathMap = FolderPathMap;
    pub static full_file_path_to_uuid: FilePathMap = FilePathMap;
}



use std::fmt;

// src/core/state/directory/types.rs
use serde::{Serialize, Deserialize};

use crate::core::{state::disks::types::{DiskID, DiskTypeEnum}, types::{ICPPrincipalString, UserID}};


#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct FolderUUID(pub String);
impl fmt::Display for FolderUUID {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct FileUUID(pub String);
impl fmt::Display for FileUUID {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct DriveFullFilePath(pub String);
impl fmt::Display for DriveFullFilePath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Tag(pub String);





#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct FolderMetadata {
    pub(crate) id: FolderUUID,
    pub(crate) name: String,
    pub(crate) parent_folder_uuid: Option<FolderUUID>,
    pub(crate) subfolder_uuids: Vec<FolderUUID>,
    pub(crate) file_uuids: Vec<FileUUID>,
    pub(crate) full_folder_path: DriveFullFilePath,
    pub(crate) tags: Vec<Tag>,
    pub(crate) created_by: UserID,
    pub(crate) created_date_ms: u64, // unix ms
    pub(crate) last_updated_date_ms: u64,  // unix ms
    pub(crate) last_updated_by: UserID,
    pub(crate) disk_id: DiskID,
    pub(crate) deleted: bool,
    pub(crate) expires_at: i64,
    pub(crate) canister_id: ICPPrincipalString,
    pub(crate) restore_trash_prior_folder_path: Option<DriveFullFilePath>,
}


#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct FileMetadata {
    pub(crate) id: FileUUID,
    pub(crate) name: String,
    pub(crate) folder_uuid: FolderUUID,
    pub(crate) file_version: u32,
    pub(crate) prior_version: Option<FileUUID>,
    pub(crate) next_version: Option<FileUUID>,
    pub(crate) extension: String,
    pub(crate) full_file_path: DriveFullFilePath,
    pub(crate) tags: Vec<Tag>,
    pub(crate) created_by: UserID,
    pub(crate) created_date_ms: u64, // unix ms
    pub(crate) disk_id: DiskID,
    pub(crate) disk_type: DiskTypeEnum,
    pub(crate) file_size: u64,
    pub(crate) raw_url: String,
    pub(crate) last_updated_date_ms: u64,  // unix ms
    pub(crate) last_updated_by: UserID,
    pub(crate) deleted: bool,
    pub(crate) canister_id: ICPPrincipalString,
    pub(crate) expires_at: i64,
    pub(crate) restore_trash_prior_folder_path: Option<DriveFullFilePath>,
}




#[derive(Serialize, Deserialize, Debug)]
pub struct PathTranslationResponse {
    pub folder: Option<FolderMetadata>,
    pub file: Option<FileMetadata>,
}
// src/core/state/disks/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::{core::{api::uuid::generate_unique_id, state::{directory::{state::state::{folder_uuid_to_metadata, full_folder_path_to_uuid}, types::{DriveFullFilePath, FolderMetadata, FolderUUID}}, disks::types::{Disk, DiskID, DiskTypeEnum}, drives::state::state::{CANISTER_ID, OWNER_ID}}, types::{ICPPrincipalString, PublicKeyBLS, UserID}}, debug_log};
    
    thread_local! {
        pub(crate) static DISKS_BY_ID_HASHTABLE: RefCell<HashMap<DiskID, Disk>> = RefCell::new(HashMap::new());
        pub(crate) static DISKS_BY_EXTERNAL_ID_HASHTABLE: RefCell<HashMap<String, DiskID>> = RefCell::new(HashMap::new());
        pub(crate) static DISKS_BY_TIME_LIST: RefCell<Vec<DiskID>> = RefCell::new(Vec::new());
    }

    pub fn init_default_disks() {

        debug_log!("Initializing default admin api key...");

        let current_canister_disk_id = generate_unique_id("DiskID", &format!("__DiskType_{}", DiskTypeEnum::IcpCanister));
        let default_canister_disk = Disk {
            id: DiskID(current_canister_disk_id.clone()),
            name: "Self Canister Storage (Default)".to_string(),
            disk_type: DiskTypeEnum::IcpCanister,
            private_note: Some("Default Canister Storage".to_string()),
            public_note: Some("Default Canister Storage".to_string()),
            auth_json: None,
            external_id: Some(ic_cdk::api::id().to_text()),
        };
        let browsercache_disk_id = generate_unique_id("DiskID", &format!("__DiskType_{}", DiskTypeEnum::BrowserCache));
        let default_browsercache_disk = Disk {
            id: DiskID(browsercache_disk_id.clone()),
            name: "Ephemeral Browser Storage (Default)".to_string(),
            disk_type: DiskTypeEnum::BrowserCache,
            private_note: Some("Offline web browser cache. Do not expect persistence in case browser history cleared.".to_string()),
            public_note: Some("Offline web browser cache. Do not expect persistence in case browser history cleared.".to_string()),
            auth_json: None,
            external_id: Some(format!("{}_DEFAULT_BROWSERCACHE_DISK_ID",ic_cdk::api::id().to_text())),
        };

        let default_disks = vec![default_canister_disk, default_browsercache_disk];

        for disk in default_disks {
            DISKS_BY_ID_HASHTABLE.with(|map| {
                map.borrow_mut().insert(disk.id.clone(), disk.clone());
            });

            DISKS_BY_EXTERNAL_ID_HASHTABLE.with(|map| {
                map.borrow_mut().insert(disk.external_id.clone().unwrap(), disk.id.clone());
            });

            DISKS_BY_TIME_LIST.with(|list| {
                list.borrow_mut().push(disk.id.clone());
            });

            OWNER_ID.with(|owner_id| {
                ensure_disk_root_folder(
                    &disk.id,
                    &owner_id.clone(),
                    &ic_cdk::api::id().to_text()
                );
            });
        }

    }

    // Helper function to create root folder for a disk
    pub fn ensure_disk_root_folder(disk_id: &DiskID, owner_id: &UserID, canister_id: &str) {
        let root_path = DriveFullFilePath(format!("{}::", disk_id.to_string()));
        
        // Only create if root folder doesn't exist
        if !full_folder_path_to_uuid.contains_key(&root_path) {
            let root_folder_uuid = generate_unique_id("FolderUUID", "");
            let root_folder = FolderMetadata {
                id: FolderUUID(root_folder_uuid.clone()),
                name: String::new(),
                parent_folder_uuid: None,
                subfolder_uuids: Vec::new(),
                file_uuids: Vec::new(),
                full_folder_path: root_path.clone(),
                tags: Vec::new(),
                created_by: owner_id.clone(),
                created_date_ms: ic_cdk::api::time(),
                disk_id: disk_id.clone(),
                last_updated_date_ms: ic_cdk::api::time() / 1_000_000,
                last_updated_by: owner_id.clone(),
                deleted: false,
                canister_id: ICPPrincipalString(PublicKeyBLS(canister_id.to_string())),
                expires_at: -1,
                restore_trash_prior_folder_path: None,
            };

            full_folder_path_to_uuid.insert(root_path, FolderUUID(root_folder_uuid.clone()));
            folder_uuid_to_metadata.insert(FolderUUID(root_folder_uuid), root_folder);
        }
    }
}



// src/core/state/disks/types.rs
use serde::{Serialize, Deserialize};
use std::fmt;


#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct DiskID(pub String);
impl fmt::Display for DiskID {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Disk {
    pub id: DiskID,
    pub name: String,
    pub disk_type: DiskTypeEnum,
    pub private_note: Option<String>,
    pub public_note: Option<String>,
    pub auth_json: Option<String>,
    pub external_id: Option<String>,
}


#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DiskTypeEnum {
    BrowserCache,
    LocalSSD,
    AwsBucket,
    StorjWeb3,
    IcpCanister,
}
impl fmt::Display for DiskTypeEnum {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DiskTypeEnum::BrowserCache => write!(f, "BrowserCache"),
            DiskTypeEnum::LocalSSD => write!(f, "LocalSSD"),
            DiskTypeEnum::AwsBucket => write!(f, "AwsBucket"),
            DiskTypeEnum::StorjWeb3 => write!(f, "StorjWeb3"),
            DiskTypeEnum::IcpCanister => write!(f, "IcpCanister"),
        }
    }
}


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AwsBucketAuth {
    pub(crate) endpoint: String,
    pub(crate) access_key: String,
    pub(crate) secret_key: String,
    pub(crate) bucket: String,
    pub(crate) region: String,  
}






// src/core/state/drives/state.rs

pub mod state {
    use std::cell::Cell;
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::core::api::uuid::generate_unique_id;
    use crate::core::state::drives::types::Drive;
    use crate::core::state::drives::types::DriveID;
    use crate::core::types::ICPPrincipalString;
    use crate::core::types::{UserID,PublicKeyBLS};

    thread_local! {
        // self info
        pub(crate) static DRIVE_ID: DriveID = DriveID(generate_unique_id("DriveID", ""));
        pub(crate) static CANISTER_ID: PublicKeyBLS = PublicKeyBLS(ic_cdk::api::id().to_text());
        pub(crate) static OWNER_ID: UserID = UserID("Anonymous_Owner".to_string());
        pub(crate) static GLOBAL_UUID_NONCE: Cell<u64> = Cell::new(0);
        // hashtables
        pub(crate) static DRIVES_BY_ID_HASHTABLE: RefCell<HashMap<DriveID, Drive>> = RefCell::new(HashMap::new());
        pub(crate) static DRIVES_BY_TIME_LIST: RefCell<Vec<DriveID>> = RefCell::new(Vec::new());
    }

    pub fn init_self_drive() {
        let self_drive = Drive {
            id: DRIVE_ID.with(|id| id.clone()),
            name: "Anonymous_Canister".to_string(),
            public_note: Some("".to_string()),
            private_note: Some("".to_string()),
            icp_principal: ICPPrincipalString(PublicKeyBLS(ic_cdk::api::id().to_text())),
        };

        DRIVES_BY_ID_HASHTABLE.with(|map| {
            map.borrow_mut().insert(self_drive.id.clone(), self_drive.clone());
        });

        DRIVES_BY_TIME_LIST.with(|list| {
            list.borrow_mut().push(self_drive.id.clone());
        });
    }
}



// src/core/state/drives/types.rs
use serde::{Serialize, Deserialize};

use crate::core::types::{ICPPrincipalString, PublicKeyBLS};


#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct DriveID(pub String);



#[derive(Debug, Clone, Serialize)]
pub struct Drive {
    pub id: DriveID,
    pub name: String,
    pub icp_principal: ICPPrincipalString,
    pub public_note: Option<String>,
    pub private_note: Option<String>,
}   


// src/core/state/team_invites/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::core::{state::team_invites::types::{TeamInviteID, Team_Invite}, types::UserID};
    
    thread_local! {
        pub(crate) static INVITES_BY_ID_HASHTABLE: RefCell<HashMap<TeamInviteID, Team_Invite>> = RefCell::new(HashMap::new());
        pub(crate) static USERS_INVITES_LIST_HASHTABLE: RefCell<HashMap<UserID, Vec<TeamInviteID>>> = RefCell::new(HashMap::new());
    }

}




// src/core/state/team_invites/types.rs
use serde::{Serialize, Deserialize};

use crate::core::state::teams::types::TeamID;
use crate::core::types::{UserID};


#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TeamInviteID(pub String);

#[derive(Debug, Clone, Serialize)]
pub struct Team_Invite {
    pub id: TeamInviteID,
    pub team_id: TeamID,
    pub inviter_id: UserID,
    pub invitee_id: UserID,
    pub role: TeamRole,
    pub active_from: u64,
    pub expires_at: i64,
    pub created_at: u64,
    pub last_modified_at: u64,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum TeamRole {
    Admin,
    Member
}


// src/core/state/teams/state.rs
pub mod state {
    use std::cell::RefCell;
    use std::collections::HashMap;

    use crate::core::{state::{team_invites::types::TeamInviteID, teams::types::{Team, TeamID}}, types::UserID};
    
    thread_local! {
        // default is to use the api key id to lookup the api key
        pub(crate) static TEAMS_BY_ID_HASHTABLE: RefCell<HashMap<TeamID, Team>> = RefCell::new(HashMap::new());
        // track in hashtable users list of ApiKeyIDs
        pub(crate) static TEAMS_BY_TIME_LIST: RefCell<Vec<TeamID>> = RefCell::new(Vec::new());
    }

}


// src/core/state/teams/types.rs
use serde::{Serialize, Deserialize};
use std::fmt;
use crate::core::{
    state::{drives::types::DriveID, team_invites::types::TeamInviteID},
    types::UserID
};

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct TeamID(pub String);

#[derive(Debug, Clone, Serialize)]
pub struct Team {
    pub id: TeamID,
    pub name: String,
    pub owner: UserID,
    pub private_note: Option<String>,
    pub public_note: Option<String>,
    pub admin_invites: Vec<TeamInviteID>, // all admin_invites are also in member_invites
    pub member_invites: Vec<TeamInviteID>,
    pub created_at: u64,
    pub last_modified_at: u64,
    pub drive_id: DriveID,
}

// Implement Display for TeamID
impl fmt::Display for TeamID {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

// Implement Display for Team
impl fmt::Display for Team {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Team {{ id: {}, name: {}, owner: {} }}", 
            self.id, self.name, self.owner)
    }
}



